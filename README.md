# CS-360

# Briefly summarize the requirements and goals of the app you developed. What user needs was this app designed to address?
The inventory app was designed to store and manage a database of inventory items. The app required a login screen with the option to create a new account. This was supported by a database of user login information. The app also required a screen with a grid which displayed inventory information. Users must be able to create, read, update, or delete items from the database. Finally, the app required notifications if an inventory item ran out of stock. Users must be able to opt out of the notifications from the database screen without impeding the other app functionality.

# What screens and features were necessary to support user needs and produce a user-centered UI for the app? How did your UI designs keep users in mind? Why were your designs successful?
In addition to the required screens, I included several other screens to support app functionality. First, I chose to create a sepearate screen for creating a new account. I envisioned this app would be used in a business setting with many employees. The account registration page took in employee information, including email addresses, to differentiate between similar accounts. On this screen, I also checked whether the requested username was unique. Because usernames are used to validate an employee login, duplicate usernames could create problems accessing separate accounts. 

The next screen I implemented was a settings screen, which was accessible from the top app bar. I included this screen to save user notification preferences. My app requested notification permissions as a popup. However, this was only accessible for Android API 33 and above. Earlier Android APIs do not require permission requests to send post notifications. Because the app is targeted for API 28 and above, I wanted to include this request on all target devices. Regardless of whether a user had enabled notifications, if they disabled notifcations on the settings screen, the app would not provide notifications. 

Finally, I chose to display screens for each inventory item. Users could access the full inventory as a list. This list included the item name, product ID, and quantity. I chose to limit the amount of details on the item list to increase readability. If a user selected an item, they would then have access to the complete item details. 

# How did you approach the process of coding your app? What techniques or strategies did you use? How could those be applied in the future?
For this project, I completed the app screen and code implementation separately. However, in both cases, I used a modular coding approach. I worked on each activity individually, starting with the main activity. I wrote the methods for the activity's main functionality. If an activity relied on a separate class, I paused work on the activity to write the class it depended on. For example, when creating the main activity, I needed to validate a user login against the database. I first wrote code handling button events which saved the entered login information. I then created the login database class. Finally, I returned to the main activity and implemented the login validation method using the login database class. Once I had completed the main functionality for the activity, I wrote functionality for its fragments. If these fragments used additional fragments, I wrote the container fragments first.

I found that this modular approach was very successful. It allowed me to narrow my focus to one method at a time. I was then better able to understand why my code was behaving unexpectedly. In future assignments with equally as complex structures, I plan to use a similar process. However, I would write the code for the app screen at the same time as its implementation.

# How did you test to ensure your code was functional? Why is this process important and what did it reveal?
My testing approach was very similar to my coding approach. I tested the application manually after completing each method. This process consisted of working through the anticipated work flow. I would click buttons to swtich between activities or update text to determine whether the method was working properly. Once I was confident that the method operated as indended, I tested interactions between methods. I then tested the behavior of the entire activity. Once I had completed work on each activity, I worked through the different fragments. I repeated my process for testing activities on the fragments. Finally, I tested the interactions between activities and fragments.

The testing process allowed me to determine which components were working correctly and which were not. Because I tested the code often and using the same inputs, I could determine which code updates caused unexpected changes.

# Considering the full app design and development process, from initial planning to finalization, where did you have to innovate to overcome a challenge?
One challenge I encountered during this process was handing interactions between detail fragments and buttons with their activity. For example, the update button on the item's detail fragment needed to update the item in the inventory database. I was able to successfully implement a button on click event for the detail fragment. However, I was not able to access the current view directly in the detail fragment. I ultimately created two methods to handle updates: one in the detail fragment class, and one in the database activity. The database activity would call the detail fragment with the current view. The detail fragment then called the update item method to update the database. I also chose to check whether the item was out of stock during inventory updates. I changed the detail fragment method to return a boolean. The boolean was true if the item was out of stock. Finally, I created a get item name method in the detail fragment, which returned the current view's item name. The detail fragment returned the item name to the database activity, which would then send an out of stock notification.

# In what specific component from your mobile app were you particularly successful in demonstrating your knowledge, skills, and experience?
I believe that incorporating images in the database most successfully demonstrated my knowledge and experience. This required me to implement several changes to my code. First, I updated the app manifest to require access to device media. I then requested this permission on the login screen. Users are able to add images to an inventory item during the add item activity. I created an activity result launcher which prompts the user to select an image. However, the most challenging aspect of incorporating images was storing images in the database. I researched how images can be stored in SQLite and discovered the blob datatype. Once a user selected an image, it is stored as a bitmap. The blob datatype supports storage of byte arrays but not bitmaps. To solve this problem, I created a class which converts bitmaps to byte arrays and back to bitmaps. The bitmap is converted to a byte array, stored in the database as a blob, and then reconverted to a bitmap when the user accesses the detail fragment. However, I found that large images sizes used up the database cursor storage. If the image was too large, the database would not display on the database activity. I added a third method to the bitmap byte conversion class which resized large images. Before an image is stored in the database, it is scaled down to save cursor memory.
